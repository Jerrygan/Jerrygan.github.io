[{"title":"泛型相关","url":"/2018/06/02/泛型相关/","content":"泛型的使用在给设计接口的时候提供类型参数，避免存取值的时候的强制类型转换，泛型的类型参数使我们的程序有着更好的可读性和安全性。泛型出现的原因就是解决类型转换问题。\n### 使用原理\n比如我们写程序定义了这样两个ArrayList<String>、ArrayList<Integer>泛型类型，我们通过这俩对象的getClass方法获取它们的类信息并比较是一样的，因为在编译期间所有的泛型类型都是被擦除，所以都是ArrayList原始类型，所谓的“类型擦除”。\n### 原始类型的概念\n就是泛型类型被擦除了泛型信息之后，在字节码中的真正类型。原始类型的名字就是删除了类型参数之后的泛型类型的类名。\n问题1 ：我们在介绍泛型时指出向ArrayList<Integer>中插入String类型的对象，编译时会报错。现在为什么又可以了呢？\n编译之后，泛型信息被擦除了。\n``` bash\nArrayList<Integer> arrayList = new ArrayList<Integer>();\narrayList.add(1);\n/*\t\t\n * 如果直接调用add方法，那么只能存储整形的数据。\n * 不过当我们利用反射调用add方法的时候，却可以存储字符串。\n * 这说明ArrayList<Integer>泛型信息在编译之后被擦除了，只保留了原始类型，类型变量（T）被替换为Object，在运行时，我们可以行其中插入任意类型的对象。\n*/\t\t\t\t\t\t\narrayList.getClass().getMethod(\"add\", Object.class).invoke(arrayList, \"test\");\nfor (int i=0;i<arrayList.size();i++) {    \n    System.out.println(arrayList.get(i));    \n}\n```\n{% asset_img 1.png 泛型截图 %}\n总结的泛型相关问题\n1.泛型类型的引用传递问题，不允许有着不一样类型变量的泛型类型之间的赋值传递。\n2.泛型类型变量不能是基本数据类型。就比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类中的类型变量（T）替换为Object，但Object类型不能存储double值。\n3.泛型在静态方法和静态类中的问题\n\n参考: [blog](https://blog.csdn.net/sunxianghuang/article/details/51982979)\n\n"}]