[{"title":"Mybatis查询缓存","url":"/2018/07/31/Mybatis查询缓存/","content":"### 一级缓存\n一级缓存作用范围在sqlSession，在同一个sqlSession中如果执行两次同样的sql查询，第一次会将查询的数据存储在HashMap缓存，第二次之后的查询便不会数据库读取数据，直接在缓存中取，从而提高查询效率；当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。如果在sqlSession有执行增删改操作，执行commit()，会清空一级缓存。\n断点位置是缓存数据key的结构，以及查询逻辑\n{% asset_img 1.png 缓存数据的key %}\n{% asset_img 2.png 缓存数据的操作 %}\n测试数据\n{% asset_img 3.png %}\n控制台输出结果：（第二次查询直接从缓存取出）\n{% asset_img 4.png %}\n这里SqlSessionFactory的openSession()自动提交是关闭的，commit()方法在增删改操作需要执行提交事务；\n{% asset_img 5.png %}\n另外，在测试注释了这句：\n{% asset_img 6.png %}\n没有执行commit()控制台输出结果：\n{% asset_img 7.png %}\n这里要知道,在数据库事务是指作为单个逻辑工作单元执行的一系列操作,要么完全地执行,要么完全地不执行，用以维护数据库的完整性。即是，在统一个单元中（事务），update执行，执行select查出来的肯定是update的数据，同一个事务没有隔离性，如果另一个单元就select不到这个update的数据，因为update的数据还没提交，只在该单元中有效。\n\n### 二级缓存\nMybatis二级缓存多个sqlSession共享，这里说的二级缓存划分以mapper.xml 定义的namespace划分，所以一样的mapper下的不同sql查询的数据放在一个缓存区域，存储结构还是HashMap，每次查询还是会先从缓存区域找，如果找不到从数据库查询，查询到数据将数据写入缓存区域，一样的，sqlSession执行insert、update、delete等操作commit提交后会清空缓存区域。\nMybatis的二级缓存是需要自己开启的，在配置文件加上\n{% asset_img 8.png %}\n还需要具体在每个mapper.xml文件加上，开启二级缓存\n{% asset_img 9.png %}\n可以增加缓存元素的属性\n{% asset_img 10.png %}\n对查询结果映射的pojo对象需要实现序列化接口（java.io.Serializable）\n\n### 总结\n应用场景：多在对数据要求实时性不高但访问查询请求多的查询结果，金额已利用二级缓存降低数据库访问量，提高访问速度，例如统计分析，可以设置刷新间隔时间\n{% asset_img 11.png %}\n局限性：Mybatis的一级缓存、二级缓存都没具体到对某个单元数据的缓存，就耳机缓存来说，如果在执行增删改的事务提交commit()之前对很多数据查询了，已经写入缓存，这时候对某个数据的增删改执行commit()会刷新缓存，即是清空缓存区域的所有缓存数据。\nMybatis提供二级缓存Cache接口，支持整合比如ehcache、memcache、redis等第三方的缓存数据库。\n"},{"title":"泛型相关","url":"/2018/06/02/泛型相关/","content":"泛型的使用在给设计接口的时候提供类型参数，避免存取值的时候的强制类型转换，泛型的类型参数使我们的程序有着更好的可读性和安全性。泛型出现的原因就是解决类型转换问题。\n### 使用原理\n比如我们写程序定义了这样两个ArrayList&lt;String&gt;、ArrayList&lt;Integer&gt;泛型类型，我们通过这俩对象的getClass方法获取它们的类信息并比较是一样的，因为在编译期间所有的泛型类型都是被擦除，所以都是ArrayList原始类型，所谓的“类型擦除”。\n### 原始类型的概念\n就是泛型类型被擦除了泛型信息之后，在字节码中的真正类型。原始类型的名字就是删除了类型参数之后的泛型类型的类名。\n问题1 ：我们在介绍泛型时指出向ArrayList<Integer>中插入String类型的对象，编译时会报错。现在为什么又可以了呢？\n编译之后，泛型信息被擦除了。\n``` bash\nArrayList<Integer> arrayList = new ArrayList<Integer>();\narrayList.add(1);\n/*\t\t\n * 如果直接调用add方法，那么只能存储整形的数据。\n * 不过当我们利用反射调用add方法的时候，却可以存储字符串。\n * 这说明ArrayList<Integer>泛型信息在编译之后被擦除了，只保留了原始类型，类型变量（T）被替换为Object，在运行时，我们可以行其中插入任意类型的对象。\n*/\t\t\t\t\t\t\narrayList.getClass().getMethod(\"add\", Object.class).invoke(arrayList, \"test\");\nfor (int i=0;i<arrayList.size();i++) {    \n    System.out.println(arrayList.get(i));    \n}\n```\n{% asset_img 1.png 泛型截图 %}\n总结的泛型相关问题\n1.泛型类型的引用传递问题，不允许有着不一样类型变量的泛型类型之间的赋值传递。\n2.泛型类型变量不能是基本数据类型。就比如，没有ArrayList&lt;double&gt;，只有ArrayList&lt;Double&gt;。因为当类型擦除后，ArrayList的原始类中的类型变量（T）替换为Object，但Object类型不能存储double值。\n3.泛型在静态方法和静态类中的问题\n\n参考: [blog](https://blog.csdn.net/sunxianghuang/article/details/51982979)\n\n"}]